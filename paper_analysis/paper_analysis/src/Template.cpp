//
// Created by qijiabao on 1/6/2024.
//
/*************************************************************************
 * @Project:     paper_analysis
 * @File:        Template.cpp
 * @Brief:       Brief description of the file
 * @Author:      qijiabao
 * @Contact:     Your Contact Information (e.g., email)
 * @Date:        1/6/2024
 * @Description: 
 *               This file is generated by CLion to provide a
 *               template for C/C++ source or header files. You can modify
 *               this template according to your project's needs.
 * @Note:        Additional notes or important points related to the file.
 * @License:     License information if applicable.
 * @Version:     Version number or other version information.
 * @TODO:        List of tasks or things to be done in the file (if any).
 * @Bug:         List of known issues or bugs (if any).
 * @IDE:         CLion
 ************************************************************************/
// Include necessary headers, if any

// Additional comments or code go here#include "Template.h"

#include "Template.h"

#include <iostream>
#include <xercesc/dom/DOMAttr.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMNamedNodeMap.hpp>
#include <xercesc/dom/DOMNodeList.hpp>

#include "CommandParser.h"
#include "EraseSpaces.h"
#include "FindElements.h"
#include "NodeToElement.h"
#include "StringExtractor.h"
#include "XMLParserFactory.h"

namespace qi {
Template::Template()
{
  // 初始化模板关键字
  //  keywords_ =
  //          {
  //                  {"本科毕业论文（设计", 0},
  //                  {"毕业论文原创性声明", 1},
  //                  {"目录", 2},
  //                  {"摘要", 3},
  //                  {"关键字", 4},
  //                  {"Abstract", 5},
  //                  {"Keywords", 6},
  //                  {"致谢", 7},
  //                  {"参考文献", 8}};

  // 创建 XMLParserFactory 对象并构建 DOM 解析器
  XMLParserFactory::createDOMParser("setting01", &templateParser_);
}
Template::Template(const std::string &templateFilePath)
{
  // 创建 XMLParserFactory 对象并构建 DOM 解析器
  XMLParserFactory::createDOMParser("setting01", &templateParser_);
  // 打开模板
  openTemplateFile(templateFilePath);
}
Template::~Template()
{
}
ErrorCode::ErrorCodeEnum Template::openTemplateFile(const std::string &templateFilePath)
{
  // 检查模板路径是否为空
  if (templateFilePath.empty())
  {
    std::cerr << "Template path is empty!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  // 保存模板路径
  templateFilePath_ = templateFilePath;
  // 保存模板名称
  templateName_ = templateFilePath.substr(templateFilePath.find_last_of('/') + 1);
  // 解析 XML 文件并获取文档
  template_ = templateParser_->parseURI(templateFilePath.c_str());
  // 检查模板是否为空
  if (template_ == nullptr)
  {
    std::cerr << "Template is empty!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  parseTemplateFile();
  return qi::ErrorCode::ErrorCodeEnum::SUCCESS;
}

ErrorCode::ErrorCodeEnum Template::setStyleFile(const std::string &styleFilePath)
{
  if (styleFilePath.empty())
  {
    std::cerr << "Template path is empty!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  style_.loadStyle(styleFilePath);
  return ErrorCode::ErrorCodeEnum::SUCCESS;
}

ErrorCode::ErrorCodeEnum Template::parseTemplateFile()
{
  // 检查模板是否为空
  if (template_ == nullptr)
  {
    std::cerr << "Template is empty!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  // 获取模板的根节点
  XERCES_CPP_NAMESPACE::DOMElement *root = template_->getDocumentElement();
  // 获取模板的所有<div>标签
  XERCES_CPP_NAMESPACE::DOMNodeList *divList = root->getElementsByTagName(XERCES_CPP_NAMESPACE::XMLString::transcode("div"));
  // 获取<div>标签数量
  keywordCount_ = divList->getLength();
  // 保存div
  XERCES_CPP_NAMESPACE::DOMNode *div = nullptr;
  // 保存转换后的字符串
  char *text1 = nullptr;
  // 保存处理后的字符串
  std::string text2 = "";
  // 清除所有空格
  EraseSpaces eraseSpaces;
  // 节点转换为元素
  NodeToElement nodeToElement;
  // 遍历<div>标签
  for (XMLSize_t i = 0; i < keywordCount_; i++)
  {
    // 获取<div>标签
    div = divList->item(i);
    // 保存转换成DOMElement的元素
    XERCES_CPP_NAMESPACE::DOMElement *element = nullptr;
    nodeToElement.nodeToElement(div, &element);
    // 保存转换成XMLCh的元素
    XMLCh *xmlString = nullptr;
    transString_.charToXMLCh("name", &xmlString);
    // 获取name标签,name标签只有一个，因为是关键字
    XERCES_CPP_NAMESPACE::DOMNodeList *elementlist = element->getElementsByTagName(xmlString);
    if (elementlist->getLength() > 1)
    {
      std::cerr << "name is more then one" << std::endl;
      // 打印所有的name
      for (XMLSize_t j = 0; j < elementlist->getLength(); j++)
      {
        XERCES_CPP_NAMESPACE::DOMNode *name = elementlist->item(j);
        std::cout << "name: " << XERCES_CPP_NAMESPACE::XMLString::transcode(name->getTextContent()) << std::endl;
      }
      return qi::ErrorCode::ErrorCodeEnum::FAILED;
    }
    XERCES_CPP_NAMESPACE::DOMNode *name = elementlist->item(0);
    transString_.xmlCharToChar(name->getTextContent(), &text1);
    text2 = text1;
    // 清除空格
    eraseSpaces.eraseSpaces(text2);
    // 清除换行
    eraseSpaces.eraseNewLine(text2);
    keywords_.insert(std::make_pair(text2, i));
  }
  //    // 打印关键字
  //    for (auto &keyword : keywords_)
  //    {
  //      std::cout << "Keywordxxx: " << keyword.first << " Index: " << keyword.second << std::endl;
  //    }
  return ErrorCode::ErrorCodeEnum::SUCCESS;
}
ErrorCode::ErrorCodeEnum Template::findKeyword(const std::string keyword, XMLSize_t **index)
{
  // 检查关键字是否为空
  if (keyword.empty())
  {
    //std::cerr << "Keyword is empty!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  auto iter = keywords_.find(keyword);
  if (iter == keywords_.end())
  {
    *index = nullptr;
    //std::cerr << "Keyword not found!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  *index = &iter->second;
  return qi::ErrorCode::ErrorCodeEnum::SUCCESS;
}

ErrorCode::ErrorCodeEnum Template::getRunStyle(const XERCES_CPP_NAMESPACE::DOMNode *run, XERCES_CPP_NAMESPACE::DOMNode **rpr)
{
  // 遍历run的所有孩子节点获取rpr样式
  XERCES_CPP_NAMESPACE::DOMNode *rprNode = nullptr;
  XERCES_CPP_NAMESPACE::DOMNode *tempNode = nullptr;
  XERCES_CPP_NAMESPACE::DOMNodeList *children = run->getChildNodes();
  for (XMLSize_t i = 0; i < children->getLength(); ++i)
  {
    tempNode = children->item(i);
    if (tempNode->getNodeType() == XERCES_CPP_NAMESPACE::DOMNode::ELEMENT_NODE)
    {
      XMLCh *rprSting = nullptr;
      transString_.charToXMLCh("w:rPr", &rprSting);
      // TODO: 2024/1/7 getLocalName() 要改成 getNodeName()
      if (XERCES_CPP_NAMESPACE::XMLString::equals(tempNode->getLocalName(), rprSting))
      {
        rprNode = tempNode;
        break;
      }
    }
  }
  // 检查rpr是否为空
  if (rprNode == nullptr)
  {
    std::cerr << "Rpr is empty!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  *rpr = rprNode;
  return ErrorCode::ErrorCodeEnum::SUCCESS;
}

ErrorCode::ErrorCodeEnum Template::getParagraphStyle(const XERCES_CPP_NAMESPACE::DOMNode *paragraph, XERCES_CPP_NAMESPACE::DOMNode **ppr)
{
  // 遍历p的所有孩子节点获取rPr样式
  XERCES_CPP_NAMESPACE::DOMNode *pprNode = nullptr;
  XERCES_CPP_NAMESPACE::DOMNode *tempNode = nullptr;
  XERCES_CPP_NAMESPACE::DOMNodeList *children = paragraph->getChildNodes();
  for (XMLSize_t i = 0; i < children->getLength(); ++i)
  {
    tempNode = children->item(i);
    if (tempNode->getNodeType() == XERCES_CPP_NAMESPACE::DOMNode::ELEMENT_NODE)
    {
      XMLCh *pprSting = nullptr;
      transString_.charToXMLCh("w:pPr", &pprSting);
      // TODO: 2024/1/7 getLocalName() 要改成 getNodeName()
      if (XERCES_CPP_NAMESPACE::XMLString::equals(tempNode->getLocalName(), pprSting))
      {
        pprNode = tempNode;
        break;
      }
    }
  }
  // 检查rpr是否为空
  if (pprNode == nullptr)
  {
    std::cerr << "Ppr is empty!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  *ppr = pprNode;
  return ErrorCode::ErrorCodeEnum::SUCCESS;
}

ErrorCode::ErrorCodeEnum Template::checkRun(const XERCES_CPP_NAMESPACE::DOMNode *run, const std::string keyword, const XERCES_CPP_NAMESPACE::DOMNode *paragraphs)
{
  // 检查关键字是否为空
  if (keyword.empty())
  {
    std::cerr << "Keyword is empty!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  // 检查run是否为空
  if (run == nullptr)
  {
    std::cerr << "Run is empty!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  // 根据关键字获取样式
  XERCES_CPP_NAMESPACE::DOMNode *style = nullptr;
  getStyleFromKey(keyword, &style);
  // 检查样式是否为空
  if (style == nullptr)
  {
    std::cerr << "Style File style is empty!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  char *text = nullptr;
  transString_.xmlCharToChar(style->getTextContent(), &text);
  std::cout << "name1: " << text << std::endl;

  // 获取run的样式
  XERCES_CPP_NAMESPACE::DOMNode *runStyle = nullptr;
  getRunStyle(run, &runStyle);
  // 检查run样式是否为空
  if (runStyle == nullptr)
  {
    // std::cerr << "Run style is empty!" << std::endl;
    getParagraphStyle(paragraphs, &runStyle);
    if (runStyle == nullptr)
    {
      style_.defaultStyle(&runStyle);
      if (runStyle == nullptr)
      {
        std::cerr << "Run style all is empty!" << std::endl;
        return qi::ErrorCode::ErrorCodeEnum::FAILED;
      }
    }
  }
  // 打印run样式
  std::cout << "Run Style: " << XERCES_CPP_NAMESPACE::XMLString::transcode(runStyle->getNodeName()) << std::endl;

  return ErrorCode::ErrorCodeEnum::SUCCESS;
}
ErrorCode::ErrorCodeEnum Template::getStyleFromKey(const std::string keyword, XERCES_CPP_NAMESPACE::DOMNode **style)
{
  // 遍历模板获取符合关键字的样式
  // 更加关键字获取样式ID
  XMLSize_t *index = nullptr;
  findKeyword(keyword, &index);
  if (index == nullptr)
  {
    std::cerr << "Keyword not found!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  // 把ID转换为XMLCh
  XMLCh *styleId = nullptr;
  transString_.xmlsize_tToXMLCh(*index, &styleId);
  char *styleIdStr = nullptr;
  transString_.xmlCharToChar(styleId, &styleIdStr);

  XERCES_CPP_NAMESPACE::DOMNode *styleNode = nullptr;
  FindElements findElements;

  findElements.FindOneElementByID(template_->getDocumentElement(), "id", styleIdStr, &styleNode);
  // 根据ID获取样式
  // 检查样式是否为空
  if (styleNode == nullptr)
  {
    std::cerr << "Style is empty!" << std::endl;
    return qi::ErrorCode::ErrorCodeEnum::FAILED;
  }
  *style = styleNode;

  return ErrorCode::ErrorCodeEnum::SUCCESS;
}

}// namespace qi


// 初始化模板关键字
//  keywords_ =
//  {
//    {1, "本科毕业论文（设计）"},
//    {2, "中文论文题目"},
//    {3, "EengligTitle"},
//    {4, "2024年1月7日"},
//    {5, "毕业论文原创性声明"},
//    {6, "目录"},
//    {7, "全文共xx页xxxx字"},
//    {8, "基于Python的高校教务管理系统的设计与实现"},
//    {9, "摘要"},
//    {10, "关键词"},
//    {11, "AnOrganixedTacticsofLargeDatabaseSystemforReal-timeCollectionandQuery"},
//    {12, "Abstract"},
//    {13, "Keywords"},
//    {14, "$main"},
//    {15, "致谢"},
//    {16, "参考文献"}
//  };