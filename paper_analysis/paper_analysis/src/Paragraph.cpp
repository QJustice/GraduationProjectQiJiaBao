//
// Created by qijiabao on 1/6/2024.
//
/*************************************************************************
 * @Project:     paper_analysis
 * @File:        main.cpp
 * @Brief:       Brief description of the file
 * @Author:      qijiabao
 * @Contact:     Your Contact Information (e.g., email)
 * @Date:        1/6/2024
 * @Description:
 *               This file is generated by CLion to provide a
 *               template for C/C++ source or header files. You can modify
 *               this template according to your project's needs.
 * @Note:        Additional notes or important points related to the file.
 * @License:     License information if applicable.
 * @Version:     Version number or other version information.
 * @TODO:        List of tasks or things to be done in the file (if any).
 * @Bug:         List of known issues or bugs (if any).
 * @IDE:         CLion
 ************************************************************************/
// Include necessary headers, if any

// Additional comments or code go here

#include "Paragraph.h"

#include <iostream>
#include <xercesc/dom/DOMNodeList.hpp>
#include <xercesc/util/XMLString.hpp>

#include "FindElements.h"
#include "NodeToElement.h"

namespace qi {

Paragraph::Paragraph()
{
}
Paragraph::Paragraph(XERCES_CPP_NAMESPACE::DOMDocument* document)
{
  // 获取文档的所有<w:p>标签
  paragraphsParser(document);
}

ErrorCode::ErrorCodeEnum Paragraph::paragraphsParser(XERCES_CPP_NAMESPACE::DOMDocument* document)
{
  // 检查文档是否为空
  if (document == nullptr)
  {
    std::cerr << "文档为空" << std::endl;
    return ErrorCode::ErrorCodeEnum::FAILED;
  }
  // 保存文档
  document_ = document;
  // 将 tempParagraph 转换为 DOMElement
  XERCES_CPP_NAMESPACE::DOMElement* convertedElement = nullptr;
  // NodeToElement 对象是用来将 DOMNode 转换为 DOMElement的工具类
  NodeToElement nodeToElement;
  // FindElements 对象是用来查找 XML 元素的工具类
  FindElements findElements;
  // document_->getDocumentElement() 获取文档的根元素
  // nodeToElement.nodeToElement(document_->getDocumentElement(), &convertedElement) 将文档的根元素转换为 DOMElement供XPath使用
  if (ErrorCode::ErrorCodeEnum::SUCCESS == nodeToElement.nodeToElement(document_->getDocumentElement(), &convertedElement))
  {
    // 查找文档的所有<w:p>标签
    findElements.FindElementByXPath(document_, convertedElement, "./body/p", &paragraphListXPath_);
  }
  else
  {
    std::cerr << "段落类型错误" << std::endl;
    return ErrorCode::ErrorCodeEnum::FAILED;
  }
  // 获取段落数量
  //  paragraphCount_ = paragraphList_->getLength();
  paragraphCount_ = paragraphListXPath_->getSnapshotLength();
  // 重置段落索引
  resetParagraphIndex();

  return ErrorCode::ErrorCodeEnum::SUCCESS;
}
ErrorCode::ErrorCodeEnum Paragraph::getParagraphCount(XMLSize_t* count) const
{
  // 获取段落数量
  *count = paragraphCount_;
  return ErrorCode::ErrorCodeEnum::SUCCESS;
}
ErrorCode::ErrorCodeEnum Paragraph::getParagraphIndex(XMLSize_t* index) const
{
  // 获取当前遍历的段落索引
  *index = paragraphIndex_;
  return ErrorCode::ErrorCodeEnum::SUCCESS;
}
ErrorCode::ErrorCodeEnum Paragraph::getParagraph(xercesc_3_2::DOMNode** paragraph) const
{
  // 获取当前遍历的段落
  paragraphListXPath_->snapshotItem(paragraphIndex_);
  // 保存段落
  *paragraph = paragraphListXPath_->getNodeValue();
  //*paragraph = paragraphList_->item(paragraphIndex_);
  return ErrorCode::ErrorCodeEnum::SUCCESS;
}
ErrorCode::ErrorCodeEnum Paragraph::nextParagraph()
{
  // 检查段落索引是否超出范围
  if (paragraphIndex_ >= paragraphCount_)
  {
    std::cerr << "段落索引超出范围" << std::endl;
    return ErrorCode::ErrorCodeEnum::FAILED;
  }
  // 段落索引加一
  ++paragraphIndex_;

  return ErrorCode::ErrorCodeEnum::SUCCESS;
}
ErrorCode::ErrorCodeEnum Paragraph::previousParagraph()
{
  // 检查段落索引是否超出范围
  if (paragraphIndex_ <= 0)
  {
    std::cerr << "段落索引超出范围" << std::endl;
    return ErrorCode::ErrorCodeEnum::FAILED;
  }
  // 段落索引减一
  --paragraphIndex_;
  return ErrorCode::ErrorCodeEnum::SUCCESS;
}
ErrorCode::ErrorCodeEnum Paragraph::resetParagraphIndex()
{
  // 重置段落索引
  paragraphIndex_ = 0;
  return ErrorCode::ErrorCodeEnum::SUCCESS;
}
ErrorCode::ErrorCodeEnum Paragraph::getParagraphProperty(XERCES_CPP_NAMESPACE::DOMNode** paragraphProperty)
{
  // 临时保存段落
  XERCES_CPP_NAMESPACE::DOMNode* paragraph = nullptr;
  // 获取当前遍历的段落
  getParagraph(&paragraph);
  if (paragraph == nullptr)
  {
    std::cerr << "paragraph is empty" << std::endl;
    return ErrorCode::ErrorCodeEnum::FAILED;
  }
  // 获取段落的<w:pPr>标签, 该标签包含段落的属性,<w:pPr>标签是<w:p>标签的第一个子标签
  std::cout << "namexxx: " << XERCES_CPP_NAMESPACE::XMLString::transcode(paragraph->getLocalName()) << std::endl;
  *paragraphProperty = paragraph->getFirstChild();

  return ErrorCode::ErrorCodeEnum::SUCCESS;
}
ErrorCode::ErrorCodeEnum Paragraph::getParagraphText(std::string& text)
{
  // 临时保存段落
  XERCES_CPP_NAMESPACE::DOMNode* paragraph = nullptr;
  // 获取当前遍历的段落
  getParagraph(&paragraph);
  if (paragraph == nullptr)
  {
    std::cerr << "paragraph is empty" << std::endl;
    return ErrorCode::ErrorCodeEnum::FAILED;
  }
  // 获取段落的文本
  // 将 XMLCh* 转换为 char*
  char* charString = nullptr;
  transString_.xmlCharToChar(paragraph->getTextContent(), &charString);
  // 保存段落的文本
  text = charString;

  return ErrorCode::ErrorCodeEnum::UNKNOWN_ERROR;
}

}// namespace qi